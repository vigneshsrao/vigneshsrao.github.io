I";Y<p><strong>Attachments</strong>: <a href="/assets/img/baby_tcache/baby_tcache">binary</a>     <a href="/assets/img/baby_tcache/libc.so.6">libc</a>     <a href="/assets/img/baby_tcache/exploit.py">exploit</a></p>

<p>This was a really fun challenge created by angelboy for HITCON CTF 2018. The following will be a writeup for the intended solution as gathered from the <a href="https://github.com/scwuaptx/CTF/blob/master/2018-writeup/hitcon/baby_tcache.py">exploit script</a> that <a href="https://twitter.com/scwuaptx">angelboy</a> uploaded.</p>

<p class="notice"><strong>Note:</strong> During the CTF we solved this challenge in a really impractical way (brute-forcing 12 bit’s of libc address to get to <code class="language-plaintext highlighter-rouge">__free_hook</code> and <code class="language-plaintext highlighter-rouge">one_gadget</code>). The intended solution is really pretty cool as it involves getting a leak which looked impossible at the start.</p>

<p>So, the binary that was provided was a stripped ELF 64 bit using libc version 2.27. The specialty of this version of libc is that, it implements the <code class="language-plaintext highlighter-rouge">tcache</code> concept that is used to cache free chunks in the heap before adding them to the libc freelist. Here are the mitigations enforced.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre>  <span class="nx">gdb</span><span class="o">-</span><span class="nx">peda$</span> <span class="nx">checksec</span>
  <span class="nx">CANARY</span>    <span class="p">:</span> <span class="nx">ENABLED</span>
  <span class="nx">FORTIFY</span>   <span class="p">:</span> <span class="nx">ENABLED</span>
  <span class="nx">NX</span>        <span class="p">:</span> <span class="nx">ENABLED</span>
  <span class="nx">PIE</span>       <span class="p">:</span> <span class="nx">ENABLED</span>
  <span class="nx">RELRO</span>     <span class="p">:</span> <span class="nx">FULL</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="reversing">Reversing</h2>

<p>Reversing this binary is pretty easy. There are only 2 functionalities</p>
<ul>
  <li><strong>new_heap:</strong> mallocs a chunk of user specified size and reads data into it. It then adds this chunk into a global array (lets call it <code class="language-plaintext highlighter-rouge">table</code>) and the size into another global array (say <code class="language-plaintext highlighter-rouge">size_arr</code>).</li>
  <li><strong>delete_heap:</strong> memsets <code class="language-plaintext highlighter-rouge">size</code> bytes of the chunk with the byte 0xda and then frees the chunk.</li>
</ul>

<h2 id="vulnerability">Vulnerability</h2>

<p>In the <code class="language-plaintext highlighter-rouge">new_heap</code> function, after reading <code class="language-plaintext highlighter-rouge">size</code> bytes of input from the user, chunk[size] is set to zero. This leads to a null-byte overflow in the <code class="language-plaintext highlighter-rouge">size</code> field of the next chunk if <code class="language-plaintext highlighter-rouge">size</code> corresponds to the exact size of the heap chunk.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="n">printf</span><span class="p">(</span><span class="s">"Data:"</span><span class="p">);</span>
<span class="n">getinp</span><span class="p">(</span><span class="n">v6</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="n">v6</span><span class="p">[</span><span class="n">size</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// Null byte overflow</span>
<span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v6</span><span class="p">;</span>
<span class="n">v3</span> <span class="o">=</span> <span class="n">size_array</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Thus we can use this to set the <code class="language-plaintext highlighter-rouge">PREV_IN_USE</code> bit of the next chunk to zero and achieve backward coalescing somewhat like what happens in House of Einherjar.</p>

<p>The main issue is that there is no way to get a leak. There is no convenient <code class="language-plaintext highlighter-rouge">view</code> functionality that we can use to get a leak. Thus we have to resort to partial overwrites, at least until we manage to get a leak (yes, though it seems stunning, we will get a leak :D)</p>

<h2 id="exploit">Exploit</h2>

<p>Before actually starting off with pwning this binary, a quick note about <code class="language-plaintext highlighter-rouge">tcache</code>. This was a new feature introduced in glibc version 2.27 and above. Now all heap chunks of size &lt; 0x410 are treated as tcache chunks. When these are freed, they go into their respective tcache bins (a singly linked list). Each bin can hold upto 7 chunks, after which chunks are freed as they were traditionally. So all chunks of size &lt; 0x410 can be thought of as fastbin chunks. But the interesting part is that, unlike fastbin chunks tcache has <strong>no</strong> security checks in place. Thus we can double free pointers and malloc sizes without <strong>any</strong> size checks.</p>

<p>Getting back to this challenge, our plan can be to achieve a backward coalescing. But since we don’t have any leaks, we will have to use a previously freed chunk as a target in our coalescing. So first, lets malloc a chunk of size &gt; 0x410 so that we have unsorted bin pointer in the chunk. Assume we have a heap structure like this -</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre>  chunk 0   # size = 0x500  =&gt; Target for backward coalescing of chunk 5. This will contain unsortedbin pointers
 ----------
  chunk 1   # size = 0x40   --+
 ----------                   |
  chunk 2   # size = 0x50     |==&gt; Random tcache chunks
 ----------                   |
  chunk 3   # size = 0x60     |
 ----------                 --+
  chunk 4   # size = 0x70 =&gt; Use this for null byte overwrite of next size
 ----------
  chunk 5   # size = 0x500 =&gt; overwrite PREV_IN_USE of this chunk
 ----------
  chunk 6   # size = 0x80 =&gt; for preventing merge with topchunk
 ----------

</pre></td></tr></tbody></table></code></pre></div></div>
<p>For overwriting the <code class="language-plaintext highlighter-rouge">PREV_IN_USE</code> of chunk 5, free and reallocate chunk 4 with size 0x68 and set the <code class="language-plaintext highlighter-rouge">PREV_SIZE</code> so as to correspond with chunk 0 (PREV_SIZE = 0x660). After freeing chunk 5, chunk 0 will be a huge chunk with which we can overwrite the tcache chunks we created.</p>

<p>So how can we get arbitrary write from this? Well lets free chunk 2 and allocate 0x500+0x40=0x540 bytes. Thus we have unsorted bin pointer as <code class="language-plaintext highlighter-rouge">fd</code> of a tcache chunk. Now we allocate a chunk of any size, such that it gets serviced from the unsorted bin and overwrite the LSB of the unsorted bin pointer to point to some place we want within the libc. Note that the last three nibbles are constant, irrespective of ASLR. So to change the last 2 bytes, we have to use 4 bit bruteforce.</p>

<p>Now our aim is to get a leak. We’ll take a diversion now and start looking into the internals of <code class="language-plaintext highlighter-rouge">puts</code>.</p>

<p><code class="language-plaintext highlighter-rouge">puts</code> internally calls <code class="language-plaintext highlighter-rouge">_IO_new_file_xsputn</code> which eventually calls <code class="language-plaintext highlighter-rouge">_IO_OVERFLOW</code></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre><span class="kt">int</span>
<span class="nf">_IO_new_file_overflow</span> <span class="p">(</span><span class="n">_IO_FILE</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">_IO_NO_WRITES</span><span class="p">)</span> <span class="cm">/* SET ERROR */</span>
    <span class="p">{</span>
      <span class="n">f</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">|=</span> <span class="n">_IO_ERR_SEEN</span><span class="p">;</span>
      <span class="n">__set_errno</span> <span class="p">(</span><span class="n">EBADF</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">EOF</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="cm">/* If currently reading or no buffer allocated. */</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">_IO_CURRENTLY_PUTTING</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">_IO_write_base</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="o">:</span>
      <span class="o">:</span>
    <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ch</span> <span class="o">==</span> <span class="n">EOF</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_IO_do_write</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">_IO_write_base</span><span class="p">,</span>  <span class="c1">// our target</span>
			 <span class="n">f</span><span class="o">-&gt;</span><span class="n">_IO_write_ptr</span> <span class="o">-</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">_IO_write_base</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>We see that <code class="language-plaintext highlighter-rouge">_IO_do_write</code> is called eventually in this function. For this <code class="language-plaintext highlighter-rouge">stdout-&gt;_flags &amp; _IO_NO_WRITES</code> should be zero. Also we set <code class="language-plaintext highlighter-rouge">stdout-&gt;_flags &amp; _IO_CURRENTLY_PUTTING</code> to avoid some unnecessary (in our case) code.</p>

<p><code class="language-plaintext highlighter-rouge">_IO_new_file_overflow</code> calls <code class="language-plaintext highlighter-rouge">_IO_do_write</code> with arguments as <code class="language-plaintext highlighter-rouge">stdout</code>, <code class="language-plaintext highlighter-rouge">stdout-&gt;_IO_write_base</code> and size of the buffer.</p>

<p><code class="language-plaintext highlighter-rouge">_IO_do_write</code> calls <code class="language-plaintext highlighter-rouge">new_do_write</code> with same arguments.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre><span class="k">static</span>
<span class="n">_IO_size_t</span>
<span class="nf">new_do_write</span> <span class="p">(</span><span class="n">_IO_FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">_IO_size_t</span> <span class="n">to_do</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">_IO_size_t</span> <span class="n">count</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">_IO_IS_APPENDING</span><span class="p">)</span>
    <span class="cm">/* On a system without a proper O_APPEND implementation,
       you would need to sys_seek(0, SEEK_END) here, but is
       not needed nor desirable for Unix- or Posix-like systems.
       Instead, just indicate that offset (before and after) is
       unpredictable. */</span>
    <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_offset</span> <span class="o">=</span> <span class="n">_IO_pos_BAD</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span> <span class="o">!=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_write_base</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">_IO_off64_t</span> <span class="n">new_pos</span>
	<span class="o">=</span> <span class="n">_IO_SYSSEEK</span> <span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_write_base</span> <span class="o">-</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">new_pos</span> <span class="o">==</span> <span class="n">_IO_pos_BAD</span><span class="p">)</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_offset</span> <span class="o">=</span> <span class="n">new_pos</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="n">count</span> <span class="o">=</span> <span class="n">_IO_SYSWRITE</span> <span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">to_do</span><span class="p">);</span> <span class="c1">// Our aim</span>
  <span class="o">:</span>
  <span class="o">:</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">_IO_SYSWRITE</code> is basically <code class="language-plaintext highlighter-rouge">write(fp-&gt;fileno, data, to_do)</code> which is what we want. Also <code class="language-plaintext highlighter-rouge">_IO_SYSSEEK</code> is basically just a call to <code class="language-plaintext highlighter-rouge">lseek</code> on the given file with the given arguments. The issue is that we don’t exactly control <code class="language-plaintext highlighter-rouge">fp-&gt;_IO_write_base - fp-&gt;_IO_read_end</code>. If we set <code class="language-plaintext highlighter-rouge">stdout-&gt;_IO_read_end</code> to zero, then the second argument is too long, and is we set <code class="language-plaintext highlighter-rouge">stdout-&gt;_IO_write_base</code> &gt; <code class="language-plaintext highlighter-rouge">stdout-&gt;_IO_read_end</code> we’ll have issues elsewhere, owing to <code class="language-plaintext highlighter-rouge">_IO_write_base</code> becomming greater than <code class="language-plaintext highlighter-rouge">_IO_write_ptr</code>. Thus our only option is to skip the <code class="language-plaintext highlighter-rouge">else if</code> block. For this we have to set <code class="language-plaintext highlighter-rouge">stdout-&gt;_flags &amp; _IO_IS_APPENDING</code></p>

<p>Therefore to get to <code class="language-plaintext highlighter-rouge">_IO_SYSWRITE</code>, we need to set the flags in the following manner</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="n">_flags</span> <span class="o">=</span> <span class="mh">0xfbad0000</span>  <span class="c1">// Magic number</span>
<span class="n">_flags</span> <span class="o">&amp;</span> <span class="o">=</span> <span class="o">~</span><span class="n">_IO_NO_WRITES</span> <span class="c1">// _flags = 0xfbad0000</span>
<span class="n">_flags</span> <span class="o">|</span> <span class="o">=</span> <span class="n">_IO_CURRENTLY_PUTTING</span> <span class="c1">// _flags = 0xfbad0800</span>
<span class="n">_flags</span> <span class="o">|</span> <span class="o">=</span> <span class="n">_IO_IS_APPENDING</span> <span class="c1">// _flags = 0xfbad1800</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>By the way did you notice the second argument of <code class="language-plaintext highlighter-rouge">_IO_do_write</code>? It’s <code class="language-plaintext highlighter-rouge">_IO_write_base</code> which is eventually the second argument for <code class="language-plaintext highlighter-rouge">write</code>. Thus we can leak data from <code class="language-plaintext highlighter-rouge">stdout-&gt;_IO_write_base</code>!</p>

<p>Now all we have to do is to set <code class="language-plaintext highlighter-rouge">stdout-&gt;_flags</code> to the value we calculated and partial overwrite <code class="language-plaintext highlighter-rouge">stdout-&gt;_IO_write_base</code> so as to point it to somewhere to get a leak.</p>

<p>So we overwrite the <code class="language-plaintext highlighter-rouge">fd</code> of our free tcache chunk to point to <code class="language-plaintext highlighter-rouge">stdout-&gt;_flags</code>. Here we will hardcode the last 2 bytes. The last 3 nibbles are constant anyway so we only need to bruteforce the fourth last nibble (4-bit bruteforce). Now we allocate a junk chunk and then chunk after that will lie in our desired region. Keep in mind that there are no size checks here, so the lack of the chunk size in the target location does not cause an issue.</p>

<p>We overwrite <code class="language-plaintext highlighter-rouge">_flags</code> with the calculated value and <code class="language-plaintext highlighter-rouge">_IO_read_ptr</code>, <code class="language-plaintext highlighter-rouge">_IO_read_end</code>, <code class="language-plaintext highlighter-rouge">_IO_read_base</code> with NULL and the last byte of <code class="language-plaintext highlighter-rouge">_IO_write_base</code> with NULL as well.</p>

<p>Heres how <code class="language-plaintext highlighter-rouge">stdout</code> looked after the overwrite</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre>gdb-peda$ x/28xg 0x00007ffff7dd0760
0x7ffff7dd0760 &lt;_IO_2_1_stdout_&gt;:       0x00000000fbad1800      0x0000000000000000
0x7ffff7dd0770 &lt;_IO_2_1_stdout_+16&gt;:    0x0000000000000000      0x0000000000000000
0x7ffff7dd0780 &lt;_IO_2_1_stdout_+32&gt;:    0x00007ffff7dd0700      0x00007ffff7dd07e3
0x7ffff7dd0790 &lt;_IO_2_1_stdout_+48&gt;:    0x00007ffff7dd07e3      0x00007ffff7dd07e3
0x7ffff7dd07a0 &lt;_IO_2_1_stdout_+64&gt;:    0x00007ffff7dd07e4      0x0000000000000000
0x7ffff7dd07b0 &lt;_IO_2_1_stdout_+80&gt;:    0x0000000000000000      0x0000000000000000
0x7ffff7dd07c0 &lt;_IO_2_1_stdout_+96&gt;:    0x0000000000000000      0x00007ffff7dcfa00
0x7ffff7dd07d0 &lt;_IO_2_1_stdout_+112&gt;:   0x0000000000000001      0xffffffffffffffff
0x7ffff7dd07e0 &lt;_IO_2_1_stdout_+128&gt;:   0x000000000a000000      0x00007ffff7dd18c0
0x7ffff7dd07f0 &lt;_IO_2_1_stdout_+144&gt;:   0xffffffffffffffff      0x0000000000000000
0x7ffff7dd0800 &lt;_IO_2_1_stdout_+160&gt;:   0x00007ffff7dcf8c0      0x0000000000000000
0x7ffff7dd0810 &lt;_IO_2_1_stdout_+176&gt;:   0x0000000000000000      0x0000000000000000
0x7ffff7dd0820 &lt;_IO_2_1_stdout_+192&gt;:   0x00000000ffffffff      0x0000000000000000
0x7ffff7dd0830 &lt;_IO_2_1_stdout_+208&gt;:   0x0000000000000000      0x00007ffff7dcc2a0
</pre></td></tr></tbody></table></code></pre></div></div>
<p>In the above structure, <code class="language-plaintext highlighter-rouge">_IO_write_base</code> = <code class="language-plaintext highlighter-rouge">0x00007ffff7dd0700</code> and <code class="language-plaintext highlighter-rouge">_IO_write_ptr</code> = <code class="language-plaintext highlighter-rouge">0x00007ffff7dd07e3</code>. So we’ll leak lot of memory in which we are sure to get a libc leak :).</p>

<p>Once we get the libc leak, exploitation is trivial. We just free another tcache chunk and overwrite its <code class="language-plaintext highlighter-rouge">fd</code> with a pointer to <code class="language-plaintext highlighter-rouge">__free_hook</code>. Then after 1 allocation of chunks in that tcache bin, we get a allocation at <code class="language-plaintext highlighter-rouge">__free_hook</code> and overwrite that with a <a href="https://github.com/david942j/one_gadget">one_gadget</a>.</p>

<p>After this we just call <code class="language-plaintext highlighter-rouge">free</code> with the <code class="language-plaintext highlighter-rouge">delete_heap</code> functionality to get shell!</p>

<p>We’ll have to run the exploit several times until our bruteforce pays off.</p>

<p>The flag was</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>hitcon{He4p_ch41leng3s_4r3_n3v3r_d34d_XD}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>My team (bi0s) stood 26 in this CTF. We had an awesome time trying out the challenges. Shout out to the HITCON team for organizing this CTF!</p>
:ET